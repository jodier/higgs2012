#ifndef __MuonTriggerMatching_h__
#define __MuonTriggerMatching_h__
/**
 * @author  Toyonobu Okuyama
 * @author  Takashi Matsushita
 */


#include <string>
#include <map>
#include <set>
#include "TTree.h"
#include "TLorentzVector.h"

#ifdef __USE_TRIGROOTANALYSIS__
#include "TrigRootAnalysis/DataAccess.h"
#endif


/**
 *  This class implements method for muon trigger matching with navigation information in ntuple analysis.
 *
 *  Validated on NTUP_SMWZ. Should work on any ntuples which contains TrigMuonD3PDMaker block
 */
class MuonTriggerMatching {
  public:
    struct EFmuon {
      bool valid;
      bool isIso;
      int iso_index;
      std::pair<int, int> indicies;
      float charge;
      float pt;
      float eta;
      float phi;

      EFmuon() : valid(false), isIso(false), iso_index(-1), indicies(), charge(0.), pt(-1.e30), eta(-1.e30), phi(-1.e30) {}
    };


    enum ChainType {
      CB = 0, // TrigMuonEF combined chain
      SA = 1, // TrigMuonEF standalone chain
      MG = 2  // TrigMuGirl
    };


    /** default constructor
     *
     * @param d3pd [in] class object used for the given ntuple analysis
#ifdef __USE_TRIGROOTANALYSIS__
     * @param tdt  [in] TrigRootAnalysis D3PD::Trig::DataAccess tool (to obtain SMK info for the current event)
#endif
     * @param TrigConfTree [in] pointer of physicsMeta/TrigConfTree block [optional]
     */
    MuonTriggerMatching(const MTT__D3PDEvent *d3pd,
#ifdef __USE_TRIGROOTANALYSIS__
                        const D3PD::Trig::DataAccess *tdt,
#endif
                        TTree *TrigConfTree=0)
      : m_d3pd(d3pd),
#ifdef __USE_TRIGROOTANALYSIS__
        m_tdt(tdt),
#endif
        m_matchingDr(0.1),
        m_isIndexMatchUsed(false),
        m_MapOfChainIdMap(),
        m_NotFoundChain() {
      readTrigConfTree(TrigConfTree);
    }
    virtual ~MuonTriggerMatching(){}


    /** returns minimum distance required for offline muon and trigger object matching
     *
     * @return m_matchingDr
     */
    double getDeltaR() const {return m_matchingDr;}


    /** set minimum distance required for offline muon and trigger object matching
     *
     * @param dr [in] matching distance for offline muon and trigger object matching
     */
    void setDeltaR(const double dr) {m_matchingDr = dr;}


    /** look for matching EF muon trigger object
     *
     * @param eta [in] eta of an offline muon
     * @param phi [in] phi of an offline muon
     * @param chain [in] single muon EF chain name. ex) "EF_mu18"
     * @param l1item [in] optional: minimum level1 threshold required for seed of the matching EF chain ex) "L1_MU11"
     * @return true if matching EF object was found false otherwise.
     */
    bool match(const double eta,
               const double phi,
               const std::string& chain,
               const std::string& l1item="");


    /** look for matching EF muon trigger object
     *
     * @param eta [in] eta of an offline muon
     * @param phi [in] phi of an offline muon
     * @param chain [in] single muon EF chain name. ex) "EF_mu18"
     * @param EFmuon [out] to be used for accessing the matched EF trigger object
     * @param l1item [in] optional: minimum level1 threshold required for seed of the matching EF chain ex) "L1_MU11"
     * @return pair of int to access trigger object
     * 
    */
    std::pair<int, int>
    matchedTrack(const double eta,
                 const double phi,
                 const std::string& chain,
                 const std::string& l1item="");


    /** look for matching EF di-muon trigger object
     *
     * @param muon1 [in] TLorentzVector of muon
     * @param muon2 [in] TLorentzVector of muon
     * @param chain [in] di-muon EF chain name. ex) "EF_2mu10"
     * @param result1 [out] bool values indicating if muon1 passed the first/second thresholds of the di-muon trigger.
     * @param result2 [out] bool values indicating if muon2 passed the first/second thresholds of the di-muon trigger.
     * @return true if matching EF object was found false otherwise.
     */
    bool matchDimuon(const TLorentzVector& muon1,
                     const TLorentzVector& muon2,
                     const std::string& chain,
                     std::pair<bool, bool>& result1,
                     std::pair<bool, bool>& result2);


    // for developers
    void showSMKeys();
    void dumpChainIdMap(const int SMK);
    void createChainIdMapFile(const int SMK);
    void setDebug(bool x) {m_debug = x;}
    void useIndex(bool x) {m_index = x;}


    /**
     *  stores information needed for di-muon trigger matching
     */
    struct DimuonChainInfo {
      public:
        std::string chain;
        std::string tightness;
        std::pair<std::string, std::string> thresholds;
        std::string l2seed;
        std::string efseed;
        bool is2011;
        bool isEFFS;
        bool is2MuXX;
        bool isValid;

        DimuonChainInfo(const std::string& chain_="") :
          chain(chain_), tightness(""), thresholds(), l2seed(""), efseed(""),
          is2011(false), isEFFS(false), is2MuXX(false), isValid(false) {}
    };


  private:
    const MTT__D3PDEvent* m_d3pd; 
#ifdef __USE_TRIGROOTANALYSIS__
    const D3PD::Trig::DataAccess* m_tdt; 
#endif 
    double m_matchingDr;
    bool m_isIndexMatchUsed;
    bool m_isNavigationMatchUsed;
    bool m_debug;
    bool m_index;
    std::map<int, std::map<std::string, int> > m_MapOfChainIdMap; // [SMK - [ChainName - ChainId] ]
    std::set<std::string> m_NotFoundChain;
    std::map<std::string, DimuonChainInfo> m_DimuonChainMap; // [chain - <threshold1, threshold2>]
  
    double matchedTrackDetail_index(EFmuon& efMuonId,
                                    const EFmuon& usedEfMuonId,
                                    const double eta,
                                    const double phi,
                                    const std::string& chainForThisMuon,
                                    const std::string& l1item="",
                                    const std::string& chainEventTrigger="");

    double matchedTrackDetail(EFmuon& efMuonId,
                              const EFmuon& usedEfMuonId,
                              const double eta,
                              const double phi,
                              const std::string& chainForThisMuon,
                              const std::string& l1item="",
                              const std::string& chainEventTrigger="");

    std::pair<bool, bool> matchDimuon(const TLorentzVector& muon1,
                                      const TLorentzVector& muon2,
                                      const DimuonChainInfo& chain);

    int getChainIndex(const std::string& chain);
    void readTrigConfTree(TTree* TrigConfTree);
    bool L1_isPassed(const int iRoI,
                     const std::string& l1item);
    int getL1pt(const std::string& l1item);
    double dR(const double eta1,
              const double phi1,
              const double eta2,
              const double phi2);
    void createChainIdMapFromFile(); //implementation in MuonChainIdMap.h

    void tokenize(const std::string& str,
                  std::vector<std::string>& tokens,
                  const std::string& delimiters);
    bool decodeDimuonChain(DimuonChainInfo& chainInfo);

    bool checkSeedL2(const double eta,
                     const double phi,
                     const std::string& chain,
                     double l2dr=0.15,
                     double l1dr=0.20);

    bool checkSeedEF(const double eta,
                     const double phi,
                     const std::string& chain);

    bool checkSeed_index(const double eta,
                         const double phi,
                         const std::string& chain);

    double index_match(const double eta,
                       const double phi,
                       const std::string& chain,
                       const std::string& threshold,
                       EFmuon& efMuonId,
                       const EFmuon& usedEfMuonId);

    bool isEqual(const double x,
                 const double y);
};


#endif //__MuonTriggerMatching_h__
// eof
